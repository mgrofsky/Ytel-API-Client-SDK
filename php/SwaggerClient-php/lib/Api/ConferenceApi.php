<?php
/**
 * ConferenceApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Ytel API V3
 *
 * Ytel API version 3
 *
 * OpenAPI spec version: 3.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ConferenceApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ConferenceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation conferencesAddParticipant
     *
     * Add Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_number The phone number of the participant to be added. (required)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesAddParticipant($conference_sid, $participant_number, $muted = null, $deaf = null)
    {
        list($response) = $this->conferencesAddParticipantWithHttpInfo($conference_sid, $participant_number, $muted, $deaf);
        return $response;
    }

    /**
     * Operation conferencesAddParticipantWithHttpInfo
     *
     * Add Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_number The phone number of the participant to be added. (required)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesAddParticipantWithHttpInfo($conference_sid, $participant_number, $muted = null, $deaf = null)
    {
        $returnType = 'string';
        $request = $this->conferencesAddParticipantRequest($conference_sid, $participant_number, $muted, $deaf);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesAddParticipantAsync
     *
     * Add Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_number The phone number of the participant to be added. (required)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesAddParticipantAsync($conference_sid, $participant_number, $muted = null, $deaf = null)
    {
        return $this->conferencesAddParticipantAsyncWithHttpInfo($conference_sid, $participant_number, $muted, $deaf)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesAddParticipantAsyncWithHttpInfo
     *
     * Add Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_number The phone number of the participant to be added. (required)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesAddParticipantAsyncWithHttpInfo($conference_sid, $participant_number, $muted = null, $deaf = null)
    {
        $returnType = 'string';
        $request = $this->conferencesAddParticipantRequest($conference_sid, $participant_number, $muted, $deaf);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesAddParticipant'
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_number The phone number of the participant to be added. (required)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesAddParticipantRequest($conference_sid, $participant_number, $muted = null, $deaf = null)
    {
        // verify the required parameter 'conference_sid' is set
        if ($conference_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_sid when calling conferencesAddParticipant'
            );
        }
        // verify the required parameter 'participant_number' is set
        if ($participant_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $participant_number when calling conferencesAddParticipant'
            );
        }

        $resourcePath = '/conferences/addParticipant.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($conference_sid !== null) {
            $formParams['ConferenceSid'] = ObjectSerializer::toFormValue($conference_sid);
        }
        // form params
        if ($participant_number !== null) {
            $formParams['ParticipantNumber'] = ObjectSerializer::toFormValue($participant_number);
        }
        // form params
        if ($muted !== null) {
            $formParams['Muted'] = ObjectSerializer::toFormValue($muted);
        }
        // form params
        if ($deaf !== null) {
            $formParams['Deaf'] = ObjectSerializer::toFormValue($deaf);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conferencesCreateConference
     *
     * Create Conference
     *
     * @param  string $from A valid 10-digit number (E.164 format) that will be initiating the conference call. (required)
     * @param  string $to A valid 10-digit number (E.164 format) that is to receive the conference call. (required)
     * @param  string $url URL requested once the conference connects (required)
     * @param  string $method Specifies the HTTP method used to request the required URL once call connects. (optional, default to POST)
     * @param  string $status_call_back_url URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the conference is finished. (optional)
     * @param  string $status_call_back_method Specifies the HTTP methodlinkclass used to request StatusCallbackUrl. (optional)
     * @param  string $fallback_url URL requested if the initial Url parameter fails or encounters an error (optional)
     * @param  string $fallback_method Specifies the HTTP method used to request the required FallbackUrl once call connects. (optional)
     * @param  bool $record Specifies if the conference should be recorded. (optional)
     * @param  string $record_call_back_url Recording parameters will be sent here upon completion. (optional)
     * @param  string $record_call_back_method Specifies the HTTP method used to request the required URL once conference connects. (optional)
     * @param  string $schedule_time Schedule conference in future. Schedule time must be greater than current time (optional)
     * @param  int $timeout The number of seconds the call stays on the line while waiting for an answer. The max time limit is 999 and the default limit is 60 seconds but lower times can be set. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesCreateConference($from, $to, $url, $method = 'POST', $status_call_back_url = null, $status_call_back_method = null, $fallback_url = null, $fallback_method = null, $record = null, $record_call_back_url = null, $record_call_back_method = null, $schedule_time = null, $timeout = null)
    {
        list($response) = $this->conferencesCreateConferenceWithHttpInfo($from, $to, $url, $method, $status_call_back_url, $status_call_back_method, $fallback_url, $fallback_method, $record, $record_call_back_url, $record_call_back_method, $schedule_time, $timeout);
        return $response;
    }

    /**
     * Operation conferencesCreateConferenceWithHttpInfo
     *
     * Create Conference
     *
     * @param  string $from A valid 10-digit number (E.164 format) that will be initiating the conference call. (required)
     * @param  string $to A valid 10-digit number (E.164 format) that is to receive the conference call. (required)
     * @param  string $url URL requested once the conference connects (required)
     * @param  string $method Specifies the HTTP method used to request the required URL once call connects. (optional, default to POST)
     * @param  string $status_call_back_url URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the conference is finished. (optional)
     * @param  string $status_call_back_method Specifies the HTTP methodlinkclass used to request StatusCallbackUrl. (optional)
     * @param  string $fallback_url URL requested if the initial Url parameter fails or encounters an error (optional)
     * @param  string $fallback_method Specifies the HTTP method used to request the required FallbackUrl once call connects. (optional)
     * @param  bool $record Specifies if the conference should be recorded. (optional)
     * @param  string $record_call_back_url Recording parameters will be sent here upon completion. (optional)
     * @param  string $record_call_back_method Specifies the HTTP method used to request the required URL once conference connects. (optional)
     * @param  string $schedule_time Schedule conference in future. Schedule time must be greater than current time (optional)
     * @param  int $timeout The number of seconds the call stays on the line while waiting for an answer. The max time limit is 999 and the default limit is 60 seconds but lower times can be set. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesCreateConferenceWithHttpInfo($from, $to, $url, $method = 'POST', $status_call_back_url = null, $status_call_back_method = null, $fallback_url = null, $fallback_method = null, $record = null, $record_call_back_url = null, $record_call_back_method = null, $schedule_time = null, $timeout = null)
    {
        $returnType = 'string';
        $request = $this->conferencesCreateConferenceRequest($from, $to, $url, $method, $status_call_back_url, $status_call_back_method, $fallback_url, $fallback_method, $record, $record_call_back_url, $record_call_back_method, $schedule_time, $timeout);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesCreateConferenceAsync
     *
     * Create Conference
     *
     * @param  string $from A valid 10-digit number (E.164 format) that will be initiating the conference call. (required)
     * @param  string $to A valid 10-digit number (E.164 format) that is to receive the conference call. (required)
     * @param  string $url URL requested once the conference connects (required)
     * @param  string $method Specifies the HTTP method used to request the required URL once call connects. (optional, default to POST)
     * @param  string $status_call_back_url URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the conference is finished. (optional)
     * @param  string $status_call_back_method Specifies the HTTP methodlinkclass used to request StatusCallbackUrl. (optional)
     * @param  string $fallback_url URL requested if the initial Url parameter fails or encounters an error (optional)
     * @param  string $fallback_method Specifies the HTTP method used to request the required FallbackUrl once call connects. (optional)
     * @param  bool $record Specifies if the conference should be recorded. (optional)
     * @param  string $record_call_back_url Recording parameters will be sent here upon completion. (optional)
     * @param  string $record_call_back_method Specifies the HTTP method used to request the required URL once conference connects. (optional)
     * @param  string $schedule_time Schedule conference in future. Schedule time must be greater than current time (optional)
     * @param  int $timeout The number of seconds the call stays on the line while waiting for an answer. The max time limit is 999 and the default limit is 60 seconds but lower times can be set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesCreateConferenceAsync($from, $to, $url, $method = 'POST', $status_call_back_url = null, $status_call_back_method = null, $fallback_url = null, $fallback_method = null, $record = null, $record_call_back_url = null, $record_call_back_method = null, $schedule_time = null, $timeout = null)
    {
        return $this->conferencesCreateConferenceAsyncWithHttpInfo($from, $to, $url, $method, $status_call_back_url, $status_call_back_method, $fallback_url, $fallback_method, $record, $record_call_back_url, $record_call_back_method, $schedule_time, $timeout)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesCreateConferenceAsyncWithHttpInfo
     *
     * Create Conference
     *
     * @param  string $from A valid 10-digit number (E.164 format) that will be initiating the conference call. (required)
     * @param  string $to A valid 10-digit number (E.164 format) that is to receive the conference call. (required)
     * @param  string $url URL requested once the conference connects (required)
     * @param  string $method Specifies the HTTP method used to request the required URL once call connects. (optional, default to POST)
     * @param  string $status_call_back_url URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the conference is finished. (optional)
     * @param  string $status_call_back_method Specifies the HTTP methodlinkclass used to request StatusCallbackUrl. (optional)
     * @param  string $fallback_url URL requested if the initial Url parameter fails or encounters an error (optional)
     * @param  string $fallback_method Specifies the HTTP method used to request the required FallbackUrl once call connects. (optional)
     * @param  bool $record Specifies if the conference should be recorded. (optional)
     * @param  string $record_call_back_url Recording parameters will be sent here upon completion. (optional)
     * @param  string $record_call_back_method Specifies the HTTP method used to request the required URL once conference connects. (optional)
     * @param  string $schedule_time Schedule conference in future. Schedule time must be greater than current time (optional)
     * @param  int $timeout The number of seconds the call stays on the line while waiting for an answer. The max time limit is 999 and the default limit is 60 seconds but lower times can be set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesCreateConferenceAsyncWithHttpInfo($from, $to, $url, $method = 'POST', $status_call_back_url = null, $status_call_back_method = null, $fallback_url = null, $fallback_method = null, $record = null, $record_call_back_url = null, $record_call_back_method = null, $schedule_time = null, $timeout = null)
    {
        $returnType = 'string';
        $request = $this->conferencesCreateConferenceRequest($from, $to, $url, $method, $status_call_back_url, $status_call_back_method, $fallback_url, $fallback_method, $record, $record_call_back_url, $record_call_back_method, $schedule_time, $timeout);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesCreateConference'
     *
     * @param  string $from A valid 10-digit number (E.164 format) that will be initiating the conference call. (required)
     * @param  string $to A valid 10-digit number (E.164 format) that is to receive the conference call. (required)
     * @param  string $url URL requested once the conference connects (required)
     * @param  string $method Specifies the HTTP method used to request the required URL once call connects. (optional, default to POST)
     * @param  string $status_call_back_url URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the conference is finished. (optional)
     * @param  string $status_call_back_method Specifies the HTTP methodlinkclass used to request StatusCallbackUrl. (optional)
     * @param  string $fallback_url URL requested if the initial Url parameter fails or encounters an error (optional)
     * @param  string $fallback_method Specifies the HTTP method used to request the required FallbackUrl once call connects. (optional)
     * @param  bool $record Specifies if the conference should be recorded. (optional)
     * @param  string $record_call_back_url Recording parameters will be sent here upon completion. (optional)
     * @param  string $record_call_back_method Specifies the HTTP method used to request the required URL once conference connects. (optional)
     * @param  string $schedule_time Schedule conference in future. Schedule time must be greater than current time (optional)
     * @param  int $timeout The number of seconds the call stays on the line while waiting for an answer. The max time limit is 999 and the default limit is 60 seconds but lower times can be set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesCreateConferenceRequest($from, $to, $url, $method = 'POST', $status_call_back_url = null, $status_call_back_method = null, $fallback_url = null, $fallback_method = null, $record = null, $record_call_back_url = null, $record_call_back_method = null, $schedule_time = null, $timeout = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling conferencesCreateConference'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling conferencesCreateConference'
            );
        }
        // verify the required parameter 'url' is set
        if ($url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling conferencesCreateConference'
            );
        }

        $resourcePath = '/conferences/createConference.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['Url'] = ObjectSerializer::toQueryValue($url);
        }


        // form params
        if ($from !== null) {
            $formParams['From'] = ObjectSerializer::toFormValue($from);
        }
        // form params
        if ($to !== null) {
            $formParams['To'] = ObjectSerializer::toFormValue($to);
        }
        // form params
        if ($method !== null) {
            $formParams['Method'] = ObjectSerializer::toFormValue($method);
        }
        // form params
        if ($status_call_back_url !== null) {
            $formParams['StatusCallBackUrl'] = ObjectSerializer::toFormValue($status_call_back_url);
        }
        // form params
        if ($status_call_back_method !== null) {
            $formParams['StatusCallBackMethod'] = ObjectSerializer::toFormValue($status_call_back_method);
        }
        // form params
        if ($fallback_url !== null) {
            $formParams['FallbackUrl'] = ObjectSerializer::toFormValue($fallback_url);
        }
        // form params
        if ($fallback_method !== null) {
            $formParams['FallbackMethod'] = ObjectSerializer::toFormValue($fallback_method);
        }
        // form params
        if ($record !== null) {
            $formParams['Record'] = ObjectSerializer::toFormValue($record);
        }
        // form params
        if ($record_call_back_url !== null) {
            $formParams['RecordCallBackUrl'] = ObjectSerializer::toFormValue($record_call_back_url);
        }
        // form params
        if ($record_call_back_method !== null) {
            $formParams['RecordCallBackMethod'] = ObjectSerializer::toFormValue($record_call_back_method);
        }
        // form params
        if ($schedule_time !== null) {
            $formParams['ScheduleTime'] = ObjectSerializer::toFormValue($schedule_time);
        }
        // form params
        if ($timeout !== null) {
            $formParams['Timeout'] = ObjectSerializer::toFormValue($timeout);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conferencesDeafMuteParticipant
     *
     * Silence Participant
     *
     * @param  string $conference_sid ID of the active conference (required)
     * @param  string $participant_sid ID of an active participant (required)
     * @param  bool $muted Mute a participant (optional)
     * @param  bool $deaf Make it so a participant cant hear (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesDeafMuteParticipant($conference_sid, $participant_sid, $muted = null, $deaf = null)
    {
        list($response) = $this->conferencesDeafMuteParticipantWithHttpInfo($conference_sid, $participant_sid, $muted, $deaf);
        return $response;
    }

    /**
     * Operation conferencesDeafMuteParticipantWithHttpInfo
     *
     * Silence Participant
     *
     * @param  string $conference_sid ID of the active conference (required)
     * @param  string $participant_sid ID of an active participant (required)
     * @param  bool $muted Mute a participant (optional)
     * @param  bool $deaf Make it so a participant cant hear (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesDeafMuteParticipantWithHttpInfo($conference_sid, $participant_sid, $muted = null, $deaf = null)
    {
        $returnType = 'string';
        $request = $this->conferencesDeafMuteParticipantRequest($conference_sid, $participant_sid, $muted, $deaf);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesDeafMuteParticipantAsync
     *
     * Silence Participant
     *
     * @param  string $conference_sid ID of the active conference (required)
     * @param  string $participant_sid ID of an active participant (required)
     * @param  bool $muted Mute a participant (optional)
     * @param  bool $deaf Make it so a participant cant hear (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesDeafMuteParticipantAsync($conference_sid, $participant_sid, $muted = null, $deaf = null)
    {
        return $this->conferencesDeafMuteParticipantAsyncWithHttpInfo($conference_sid, $participant_sid, $muted, $deaf)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesDeafMuteParticipantAsyncWithHttpInfo
     *
     * Silence Participant
     *
     * @param  string $conference_sid ID of the active conference (required)
     * @param  string $participant_sid ID of an active participant (required)
     * @param  bool $muted Mute a participant (optional)
     * @param  bool $deaf Make it so a participant cant hear (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesDeafMuteParticipantAsyncWithHttpInfo($conference_sid, $participant_sid, $muted = null, $deaf = null)
    {
        $returnType = 'string';
        $request = $this->conferencesDeafMuteParticipantRequest($conference_sid, $participant_sid, $muted, $deaf);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesDeafMuteParticipant'
     *
     * @param  string $conference_sid ID of the active conference (required)
     * @param  string $participant_sid ID of an active participant (required)
     * @param  bool $muted Mute a participant (optional)
     * @param  bool $deaf Make it so a participant cant hear (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesDeafMuteParticipantRequest($conference_sid, $participant_sid, $muted = null, $deaf = null)
    {
        // verify the required parameter 'conference_sid' is set
        if ($conference_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_sid when calling conferencesDeafMuteParticipant'
            );
        }
        // verify the required parameter 'participant_sid' is set
        if ($participant_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $participant_sid when calling conferencesDeafMuteParticipant'
            );
        }

        $resourcePath = '/conferences/deafMuteParticipant.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($conference_sid !== null) {
            $formParams['conferenceSid'] = ObjectSerializer::toFormValue($conference_sid);
        }
        // form params
        if ($participant_sid !== null) {
            $formParams['ParticipantSid'] = ObjectSerializer::toFormValue($participant_sid);
        }
        // form params
        if ($muted !== null) {
            $formParams['Muted'] = ObjectSerializer::toFormValue($muted);
        }
        // form params
        if ($deaf !== null) {
            $formParams['Deaf'] = ObjectSerializer::toFormValue($deaf);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conferencesHangupParticipant
     *
     * Hangup Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesHangupParticipant($conference_sid, $participant_sid)
    {
        list($response) = $this->conferencesHangupParticipantWithHttpInfo($conference_sid, $participant_sid);
        return $response;
    }

    /**
     * Operation conferencesHangupParticipantWithHttpInfo
     *
     * Hangup Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesHangupParticipantWithHttpInfo($conference_sid, $participant_sid)
    {
        $returnType = 'string';
        $request = $this->conferencesHangupParticipantRequest($conference_sid, $participant_sid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesHangupParticipantAsync
     *
     * Hangup Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesHangupParticipantAsync($conference_sid, $participant_sid)
    {
        return $this->conferencesHangupParticipantAsyncWithHttpInfo($conference_sid, $participant_sid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesHangupParticipantAsyncWithHttpInfo
     *
     * Hangup Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesHangupParticipantAsyncWithHttpInfo($conference_sid, $participant_sid)
    {
        $returnType = 'string';
        $request = $this->conferencesHangupParticipantRequest($conference_sid, $participant_sid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesHangupParticipant'
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesHangupParticipantRequest($conference_sid, $participant_sid)
    {
        // verify the required parameter 'conference_sid' is set
        if ($conference_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_sid when calling conferencesHangupParticipant'
            );
        }
        // verify the required parameter 'participant_sid' is set
        if ($participant_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $participant_sid when calling conferencesHangupParticipant'
            );
        }

        $resourcePath = '/conferences/hangupParticipant.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($participant_sid !== null) {
            $queryParams['ParticipantSid'] = ObjectSerializer::toQueryValue($participant_sid);
        }


        // form params
        if ($conference_sid !== null) {
            $formParams['ConferenceSid'] = ObjectSerializer::toFormValue($conference_sid);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conferencesListParticipant
     *
     * List Participants
     *
     * @param  string $conference_sid The unique identifier for a conference. (required)
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize The count of objects to return per page. (optional, default to 10)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesListParticipant($conference_sid, $page = '1', $pagesize = '10', $muted = null, $deaf = null)
    {
        list($response) = $this->conferencesListParticipantWithHttpInfo($conference_sid, $page, $pagesize, $muted, $deaf);
        return $response;
    }

    /**
     * Operation conferencesListParticipantWithHttpInfo
     *
     * List Participants
     *
     * @param  string $conference_sid The unique identifier for a conference. (required)
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize The count of objects to return per page. (optional, default to 10)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesListParticipantWithHttpInfo($conference_sid, $page = '1', $pagesize = '10', $muted = null, $deaf = null)
    {
        $returnType = 'string';
        $request = $this->conferencesListParticipantRequest($conference_sid, $page, $pagesize, $muted, $deaf);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesListParticipantAsync
     *
     * List Participants
     *
     * @param  string $conference_sid The unique identifier for a conference. (required)
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize The count of objects to return per page. (optional, default to 10)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesListParticipantAsync($conference_sid, $page = '1', $pagesize = '10', $muted = null, $deaf = null)
    {
        return $this->conferencesListParticipantAsyncWithHttpInfo($conference_sid, $page, $pagesize, $muted, $deaf)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesListParticipantAsyncWithHttpInfo
     *
     * List Participants
     *
     * @param  string $conference_sid The unique identifier for a conference. (required)
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize The count of objects to return per page. (optional, default to 10)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesListParticipantAsyncWithHttpInfo($conference_sid, $page = '1', $pagesize = '10', $muted = null, $deaf = null)
    {
        $returnType = 'string';
        $request = $this->conferencesListParticipantRequest($conference_sid, $page, $pagesize, $muted, $deaf);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesListParticipant'
     *
     * @param  string $conference_sid The unique identifier for a conference. (required)
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize The count of objects to return per page. (optional, default to 10)
     * @param  bool $muted Specifies if participant should be muted. (optional)
     * @param  bool $deaf Specifies if the participant should hear audio in the conference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesListParticipantRequest($conference_sid, $page = '1', $pagesize = '10', $muted = null, $deaf = null)
    {
        // verify the required parameter 'conference_sid' is set
        if ($conference_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_sid when calling conferencesListParticipant'
            );
        }

        $resourcePath = '/conferences/listParticipant.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($conference_sid !== null) {
            $formParams['ConferenceSid'] = ObjectSerializer::toFormValue($conference_sid);
        }
        // form params
        if ($page !== null) {
            $formParams['Page'] = ObjectSerializer::toFormValue($page);
        }
        // form params
        if ($pagesize !== null) {
            $formParams['Pagesize'] = ObjectSerializer::toFormValue($pagesize);
        }
        // form params
        if ($muted !== null) {
            $formParams['Muted'] = ObjectSerializer::toFormValue($muted);
        }
        // form params
        if ($deaf !== null) {
            $formParams['Deaf'] = ObjectSerializer::toFormValue($deaf);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conferencesListconference
     *
     * List Conferences
     *
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize Number of individual resources listed in the response per page (optional, default to 10)
     * @param  string $friendly_name Only return conferences with the specified FriendlyName (optional)
     * @param  string $date_created Conference created date (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesListconference($page = '1', $pagesize = '10', $friendly_name = null, $date_created = null)
    {
        list($response) = $this->conferencesListconferenceWithHttpInfo($page, $pagesize, $friendly_name, $date_created);
        return $response;
    }

    /**
     * Operation conferencesListconferenceWithHttpInfo
     *
     * List Conferences
     *
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize Number of individual resources listed in the response per page (optional, default to 10)
     * @param  string $friendly_name Only return conferences with the specified FriendlyName (optional)
     * @param  string $date_created Conference created date (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesListconferenceWithHttpInfo($page = '1', $pagesize = '10', $friendly_name = null, $date_created = null)
    {
        $returnType = 'string';
        $request = $this->conferencesListconferenceRequest($page, $pagesize, $friendly_name, $date_created);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesListconferenceAsync
     *
     * List Conferences
     *
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize Number of individual resources listed in the response per page (optional, default to 10)
     * @param  string $friendly_name Only return conferences with the specified FriendlyName (optional)
     * @param  string $date_created Conference created date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesListconferenceAsync($page = '1', $pagesize = '10', $friendly_name = null, $date_created = null)
    {
        return $this->conferencesListconferenceAsyncWithHttpInfo($page, $pagesize, $friendly_name, $date_created)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesListconferenceAsyncWithHttpInfo
     *
     * List Conferences
     *
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize Number of individual resources listed in the response per page (optional, default to 10)
     * @param  string $friendly_name Only return conferences with the specified FriendlyName (optional)
     * @param  string $date_created Conference created date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesListconferenceAsyncWithHttpInfo($page = '1', $pagesize = '10', $friendly_name = null, $date_created = null)
    {
        $returnType = 'string';
        $request = $this->conferencesListconferenceRequest($page, $pagesize, $friendly_name, $date_created);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesListconference'
     *
     * @param  int $page The page count to retrieve from the total results in the collection. Page indexing starts at 1. (optional, default to 1)
     * @param  int $pagesize Number of individual resources listed in the response per page (optional, default to 10)
     * @param  string $friendly_name Only return conferences with the specified FriendlyName (optional)
     * @param  string $date_created Conference created date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesListconferenceRequest($page = '1', $pagesize = '10', $friendly_name = null, $date_created = null)
    {

        $resourcePath = '/conferences/listconference.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($page !== null) {
            $formParams['page'] = ObjectSerializer::toFormValue($page);
        }
        // form params
        if ($pagesize !== null) {
            $formParams['pagesize'] = ObjectSerializer::toFormValue($pagesize);
        }
        // form params
        if ($friendly_name !== null) {
            $formParams['FriendlyName'] = ObjectSerializer::toFormValue($friendly_name);
        }
        // form params
        if ($date_created !== null) {
            $formParams['DateCreated'] = ObjectSerializer::toFormValue($date_created);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conferencesPlayAudio
     *
     * Play Audio
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     * @param  string $audio_url The URL for the audio file that is to be played during the conference. Multiple audio files can be chained by using a semicolon. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesPlayAudio($conference_sid, $participant_sid, $audio_url)
    {
        list($response) = $this->conferencesPlayAudioWithHttpInfo($conference_sid, $participant_sid, $audio_url);
        return $response;
    }

    /**
     * Operation conferencesPlayAudioWithHttpInfo
     *
     * Play Audio
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     * @param  string $audio_url The URL for the audio file that is to be played during the conference. Multiple audio files can be chained by using a semicolon. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesPlayAudioWithHttpInfo($conference_sid, $participant_sid, $audio_url)
    {
        $returnType = 'string';
        $request = $this->conferencesPlayAudioRequest($conference_sid, $participant_sid, $audio_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesPlayAudioAsync
     *
     * Play Audio
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     * @param  string $audio_url The URL for the audio file that is to be played during the conference. Multiple audio files can be chained by using a semicolon. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesPlayAudioAsync($conference_sid, $participant_sid, $audio_url)
    {
        return $this->conferencesPlayAudioAsyncWithHttpInfo($conference_sid, $participant_sid, $audio_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesPlayAudioAsyncWithHttpInfo
     *
     * Play Audio
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     * @param  string $audio_url The URL for the audio file that is to be played during the conference. Multiple audio files can be chained by using a semicolon. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesPlayAudioAsyncWithHttpInfo($conference_sid, $participant_sid, $audio_url)
    {
        $returnType = 'string';
        $request = $this->conferencesPlayAudioRequest($conference_sid, $participant_sid, $audio_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesPlayAudio'
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     * @param  string $audio_url The URL for the audio file that is to be played during the conference. Multiple audio files can be chained by using a semicolon. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesPlayAudioRequest($conference_sid, $participant_sid, $audio_url)
    {
        // verify the required parameter 'conference_sid' is set
        if ($conference_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_sid when calling conferencesPlayAudio'
            );
        }
        // verify the required parameter 'participant_sid' is set
        if ($participant_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $participant_sid when calling conferencesPlayAudio'
            );
        }
        // verify the required parameter 'audio_url' is set
        if ($audio_url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audio_url when calling conferencesPlayAudio'
            );
        }

        $resourcePath = '/conferences/playAudio.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($conference_sid !== null) {
            $formParams['ConferenceSid'] = ObjectSerializer::toFormValue($conference_sid);
        }
        // form params
        if ($participant_sid !== null) {
            $formParams['ParticipantSid'] = ObjectSerializer::toFormValue($participant_sid);
        }
        // form params
        if ($audio_url !== null) {
            $formParams['AudioUrl'] = ObjectSerializer::toFormValue($audio_url);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conferencesViewParticipant
     *
     * View Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesViewParticipant($conference_sid, $participant_sid)
    {
        list($response) = $this->conferencesViewParticipantWithHttpInfo($conference_sid, $participant_sid);
        return $response;
    }

    /**
     * Operation conferencesViewParticipantWithHttpInfo
     *
     * View Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesViewParticipantWithHttpInfo($conference_sid, $participant_sid)
    {
        $returnType = 'string';
        $request = $this->conferencesViewParticipantRequest($conference_sid, $participant_sid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesViewParticipantAsync
     *
     * View Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesViewParticipantAsync($conference_sid, $participant_sid)
    {
        return $this->conferencesViewParticipantAsyncWithHttpInfo($conference_sid, $participant_sid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesViewParticipantAsyncWithHttpInfo
     *
     * View Participant
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesViewParticipantAsyncWithHttpInfo($conference_sid, $participant_sid)
    {
        $returnType = 'string';
        $request = $this->conferencesViewParticipantRequest($conference_sid, $participant_sid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesViewParticipant'
     *
     * @param  string $conference_sid The unique identifier for a conference object. (required)
     * @param  string $participant_sid The unique identifier for a participant object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesViewParticipantRequest($conference_sid, $participant_sid)
    {
        // verify the required parameter 'conference_sid' is set
        if ($conference_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_sid when calling conferencesViewParticipant'
            );
        }
        // verify the required parameter 'participant_sid' is set
        if ($participant_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $participant_sid when calling conferencesViewParticipant'
            );
        }

        $resourcePath = '/conferences/viewParticipant.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($conference_sid !== null) {
            $formParams['ConferenceSid'] = ObjectSerializer::toFormValue($conference_sid);
        }
        // form params
        if ($participant_sid !== null) {
            $formParams['ParticipantSid'] = ObjectSerializer::toFormValue($participant_sid);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conferencesViewconference
     *
     * View Conference
     *
     * @param  string $conference_sid The unique identifier of each conference resource (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function conferencesViewconference($conference_sid)
    {
        list($response) = $this->conferencesViewconferenceWithHttpInfo($conference_sid);
        return $response;
    }

    /**
     * Operation conferencesViewconferenceWithHttpInfo
     *
     * View Conference
     *
     * @param  string $conference_sid The unique identifier of each conference resource (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function conferencesViewconferenceWithHttpInfo($conference_sid)
    {
        $returnType = 'string';
        $request = $this->conferencesViewconferenceRequest($conference_sid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conferencesViewconferenceAsync
     *
     * View Conference
     *
     * @param  string $conference_sid The unique identifier of each conference resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesViewconferenceAsync($conference_sid)
    {
        return $this->conferencesViewconferenceAsyncWithHttpInfo($conference_sid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conferencesViewconferenceAsyncWithHttpInfo
     *
     * View Conference
     *
     * @param  string $conference_sid The unique identifier of each conference resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conferencesViewconferenceAsyncWithHttpInfo($conference_sid)
    {
        $returnType = 'string';
        $request = $this->conferencesViewconferenceRequest($conference_sid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conferencesViewconference'
     *
     * @param  string $conference_sid The unique identifier of each conference resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conferencesViewconferenceRequest($conference_sid)
    {
        // verify the required parameter 'conference_sid' is set
        if ($conference_sid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_sid when calling conferencesViewconference'
            );
        }

        $resourcePath = '/conferences/viewconference.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($conference_sid !== null) {
            $formParams['ConferenceSid'] = ObjectSerializer::toFormValue($conference_sid);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
