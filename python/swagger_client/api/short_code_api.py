# coding: utf-8

"""
    Ytel API V3

    Ytel API version 3  # noqa: E501

    OpenAPI spec version: 3.11
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ShortCodeApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def dedicatedshortcode_getinboundsms(self, **kwargs):  # noqa: E501
        """List Inbound SMS  # noqa: E501

        Retrive a list of inbound Sms Short Code messages associated with your Ytel account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_getinboundsms(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: Number of individual resources listed in the response per page
        :param str _from: Only list SMS messages sent from this number
        :param str shortcode: Only list SMS messages sent to Shortcode
        :param str datecreated: Only list SMS messages sent in the specified date MAKE REQUEST
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.dedicatedshortcode_getinboundsms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dedicatedshortcode_getinboundsms_with_http_info(**kwargs)  # noqa: E501
            return data

    def dedicatedshortcode_getinboundsms_with_http_info(self, **kwargs):  # noqa: E501
        """List Inbound SMS  # noqa: E501

        Retrive a list of inbound Sms Short Code messages associated with your Ytel account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_getinboundsms_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: Number of individual resources listed in the response per page
        :param str _from: Only list SMS messages sent from this number
        :param str shortcode: Only list SMS messages sent to Shortcode
        :param str datecreated: Only list SMS messages sent in the specified date MAKE REQUEST
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'pagesize', '_from', 'shortcode', 'datecreated']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dedicatedshortcode_getinboundsms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'page' in params:
            form_params.append(('page', params['page']))  # noqa: E501
        if 'pagesize' in params:
            form_params.append(('pagesize', params['pagesize']))  # noqa: E501
        if '_from' in params:
            form_params.append(('From', params['_from']))  # noqa: E501
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501
        if 'datecreated' in params:
            form_params.append(('Datecreated', params['datecreated']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/dedicatedshortcode/getinboundsms.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dedicatedshortcode_listshortcode(self, **kwargs):  # noqa: E501
        """List Shortcodes  # noqa: E501

        Retrieve a list of Short Code assignment associated with your Ytel account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_listshortcode(async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: Only list Short Code Assignment sent from this Short Code
        :param str page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param str pagesize: The count of objects to return per page.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.dedicatedshortcode_listshortcode_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dedicatedshortcode_listshortcode_with_http_info(**kwargs)  # noqa: E501
            return data

    def dedicatedshortcode_listshortcode_with_http_info(self, **kwargs):  # noqa: E501
        """List Shortcodes  # noqa: E501

        Retrieve a list of Short Code assignment associated with your Ytel account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_listshortcode_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: Only list Short Code Assignment sent from this Short Code
        :param str page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param str pagesize: The count of objects to return per page.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shortcode', 'page', 'pagesize']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dedicatedshortcode_listshortcode" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501
        if 'page' in params:
            form_params.append(('page', params['page']))  # noqa: E501
        if 'pagesize' in params:
            form_params.append(('pagesize', params['pagesize']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/dedicatedshortcode/listshortcode.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dedicatedshortcode_sendsms(self, shortcode, to, body, **kwargs):  # noqa: E501
        """Send SMS  # noqa: E501

        Send Dedicated Shortcode  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_sendsms(shortcode, to, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int shortcode: Your dedicated shortcode (required)
        :param float to: The number to send your SMS to (required)
        :param str body: The body of your message (required)
        :param str method: Specifies the HTTP method used to request the required URL once the Short Code message is sent.GET or POST
        :param str messagestatuscallback: URL that can be requested to receive notification when Short Code message was sent.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.dedicatedshortcode_sendsms_with_http_info(shortcode, to, body, **kwargs)  # noqa: E501
        else:
            (data) = self.dedicatedshortcode_sendsms_with_http_info(shortcode, to, body, **kwargs)  # noqa: E501
            return data

    def dedicatedshortcode_sendsms_with_http_info(self, shortcode, to, body, **kwargs):  # noqa: E501
        """Send SMS  # noqa: E501

        Send Dedicated Shortcode  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_sendsms_with_http_info(shortcode, to, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int shortcode: Your dedicated shortcode (required)
        :param float to: The number to send your SMS to (required)
        :param str body: The body of your message (required)
        :param str method: Specifies the HTTP method used to request the required URL once the Short Code message is sent.GET or POST
        :param str messagestatuscallback: URL that can be requested to receive notification when Short Code message was sent.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shortcode', 'to', 'body', 'method', 'messagestatuscallback']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dedicatedshortcode_sendsms" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shortcode' is set
        if ('shortcode' not in params or
                params['shortcode'] is None):
            raise ValueError("Missing the required parameter `shortcode` when calling `dedicatedshortcode_sendsms`")  # noqa: E501
        # verify the required parameter 'to' is set
        if ('to' not in params or
                params['to'] is None):
            raise ValueError("Missing the required parameter `to` when calling `dedicatedshortcode_sendsms`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `dedicatedshortcode_sendsms`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'shortcode' in params:
            form_params.append(('shortcode', params['shortcode']))  # noqa: E501
        if 'to' in params:
            form_params.append(('to', params['to']))  # noqa: E501
        if 'body' in params:
            form_params.append(('body', params['body']))  # noqa: E501
        if 'method' in params:
            form_params.append(('method', params['method']))  # noqa: E501
        if 'messagestatuscallback' in params:
            form_params.append(('messagestatuscallback', params['messagestatuscallback']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/dedicatedshortcode/sendsms.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dedicatedshortcode_updateshortcode(self, shortcode, **kwargs):  # noqa: E501
        """Update Shortcode  # noqa: E501

        Update a dedicated shortcode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_updateshortcode(shortcode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: List of valid dedicated shortcode to your Ytel account. (required)
        :param str friendly_name: User generated name of the dedicated shortcode.
        :param str callback_method: Specifies the HTTP method used to request the required StatusCallBackUrl once call connects.
        :param str callback_url: URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the call is finished.
        :param str fallback_method: Specifies the HTTP method used to request the required FallbackUrl once call connects.
        :param str fallback_url: URL used if any errors occur during execution of InboundXML or at initial request of the required Url provided with the POST.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.dedicatedshortcode_updateshortcode_with_http_info(shortcode, **kwargs)  # noqa: E501
        else:
            (data) = self.dedicatedshortcode_updateshortcode_with_http_info(shortcode, **kwargs)  # noqa: E501
            return data

    def dedicatedshortcode_updateshortcode_with_http_info(self, shortcode, **kwargs):  # noqa: E501
        """Update Shortcode  # noqa: E501

        Update a dedicated shortcode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_updateshortcode_with_http_info(shortcode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: List of valid dedicated shortcode to your Ytel account. (required)
        :param str friendly_name: User generated name of the dedicated shortcode.
        :param str callback_method: Specifies the HTTP method used to request the required StatusCallBackUrl once call connects.
        :param str callback_url: URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the call is finished.
        :param str fallback_method: Specifies the HTTP method used to request the required FallbackUrl once call connects.
        :param str fallback_url: URL used if any errors occur during execution of InboundXML or at initial request of the required Url provided with the POST.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shortcode', 'friendly_name', 'callback_method', 'callback_url', 'fallback_method', 'fallback_url']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dedicatedshortcode_updateshortcode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shortcode' is set
        if ('shortcode' not in params or
                params['shortcode'] is None):
            raise ValueError("Missing the required parameter `shortcode` when calling `dedicatedshortcode_updateshortcode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501
        if 'friendly_name' in params:
            form_params.append(('FriendlyName', params['friendly_name']))  # noqa: E501
        if 'callback_method' in params:
            form_params.append(('CallbackMethod', params['callback_method']))  # noqa: E501
        if 'callback_url' in params:
            form_params.append(('CallbackUrl', params['callback_url']))  # noqa: E501
        if 'fallback_method' in params:
            form_params.append(('FallbackMethod', params['fallback_method']))  # noqa: E501
        if 'fallback_url' in params:
            form_params.append(('FallbackUrl', params['fallback_url']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/dedicatedshortcode/updateshortcode.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dedicatedshortcode_viewshortcode(self, shortcode, **kwargs):  # noqa: E501
        """View SMS  # noqa: E501

        Retrieve a single Short Code object by its shortcode assignment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_viewshortcode(shortcode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: List of valid Dedicated Short Code to your Ytel account (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.dedicatedshortcode_viewshortcode_with_http_info(shortcode, **kwargs)  # noqa: E501
        else:
            (data) = self.dedicatedshortcode_viewshortcode_with_http_info(shortcode, **kwargs)  # noqa: E501
            return data

    def dedicatedshortcode_viewshortcode_with_http_info(self, shortcode, **kwargs):  # noqa: E501
        """View SMS  # noqa: E501

        Retrieve a single Short Code object by its shortcode assignment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.dedicatedshortcode_viewshortcode_with_http_info(shortcode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: List of valid Dedicated Short Code to your Ytel account (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shortcode']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dedicatedshortcode_viewshortcode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shortcode' is set
        if ('shortcode' not in params or
                params['shortcode'] is None):
            raise ValueError("Missing the required parameter `shortcode` when calling `dedicatedshortcode_viewshortcode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/dedicatedshortcode/viewshortcode.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shortcode_listsms(self, **kwargs):  # noqa: E501
        """List SMS  # noqa: E501

        Retrieve a list of Short Code messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_listsms(async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: Only list messages sent from this Short Code
        :param str to: Only list messages sent to this number
        :param str date_sent: Only list messages sent with the specified date
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int page_size: The count of objects to return per page.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.shortcode_listsms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.shortcode_listsms_with_http_info(**kwargs)  # noqa: E501
            return data

    def shortcode_listsms_with_http_info(self, **kwargs):  # noqa: E501
        """List SMS  # noqa: E501

        Retrieve a list of Short Code messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_listsms_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: Only list messages sent from this Short Code
        :param str to: Only list messages sent to this number
        :param str date_sent: Only list messages sent with the specified date
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int page_size: The count of objects to return per page.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shortcode', 'to', 'date_sent', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shortcode_listsms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501
        if 'to' in params:
            form_params.append(('To', params['to']))  # noqa: E501
        if 'date_sent' in params:
            form_params.append(('DateSent', params['date_sent']))  # noqa: E501
        if 'page' in params:
            form_params.append(('Page', params['page']))  # noqa: E501
        if 'page_size' in params:
            form_params.append(('PageSize', params['page_size']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/shortcode/listsms.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shortcode_viewsms(self, message_sid, **kwargs):  # noqa: E501
        """View SMS  # noqa: E501

        View a single Sms Short Code message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_viewsms(message_sid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str message_sid: The unique identifier for the sms resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.shortcode_viewsms_with_http_info(message_sid, **kwargs)  # noqa: E501
        else:
            (data) = self.shortcode_viewsms_with_http_info(message_sid, **kwargs)  # noqa: E501
            return data

    def shortcode_viewsms_with_http_info(self, message_sid, **kwargs):  # noqa: E501
        """View SMS  # noqa: E501

        View a single Sms Short Code message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_viewsms_with_http_info(message_sid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str message_sid: The unique identifier for the sms resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_sid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shortcode_viewsms" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'message_sid' is set
        if ('message_sid' not in params or
                params['message_sid'] is None):
            raise ValueError("Missing the required parameter `message_sid` when calling `shortcode_viewsms`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'message_sid' in params:
            form_params.append(('MessageSid', params['message_sid']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/shortcode/viewsms.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
