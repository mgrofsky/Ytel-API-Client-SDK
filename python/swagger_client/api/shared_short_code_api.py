# coding: utf-8

"""
    Ytel API V3

    Ytel API version 3  # noqa: E501

    OpenAPI spec version: 3.11
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class SharedShortCodeApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def keyword_lists(self, **kwargs):  # noqa: E501
        """List Keywords  # noqa: E501

        Retrieve a list of keywords associated with your Ytel account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.keyword_lists(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: Number of individual resources listed in the response per page
        :param str keyword: Only list keywords of keyword
        :param int shortcode: Only list keywords of shortcode
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.keyword_lists_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.keyword_lists_with_http_info(**kwargs)  # noqa: E501
            return data

    def keyword_lists_with_http_info(self, **kwargs):  # noqa: E501
        """List Keywords  # noqa: E501

        Retrieve a list of keywords associated with your Ytel account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.keyword_lists_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: Number of individual resources listed in the response per page
        :param str keyword: Only list keywords of keyword
        :param int shortcode: Only list keywords of shortcode
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'pagesize', 'keyword', 'shortcode']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method keyword_lists" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'page' in params:
            form_params.append(('page', params['page']))  # noqa: E501
        if 'pagesize' in params:
            form_params.append(('pagesize', params['pagesize']))  # noqa: E501
        if 'keyword' in params:
            form_params.append(('Keyword', params['keyword']))  # noqa: E501
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/keyword/lists.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def keyword_view(self, keywordid, **kwargs):  # noqa: E501
        """View Keyword  # noqa: E501

        View a set of properties for a single keyword.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.keyword_view(keywordid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str keywordid: The unique identifier of each keyword (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.keyword_view_with_http_info(keywordid, **kwargs)  # noqa: E501
        else:
            (data) = self.keyword_view_with_http_info(keywordid, **kwargs)  # noqa: E501
            return data

    def keyword_view_with_http_info(self, keywordid, **kwargs):  # noqa: E501
        """View Keyword  # noqa: E501

        View a set of properties for a single keyword.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.keyword_view_with_http_info(keywordid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str keywordid: The unique identifier of each keyword (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['keywordid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method keyword_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'keywordid' is set
        if ('keywordid' not in params or
                params['keywordid'] is None):
            raise ValueError("Missing the required parameter `keywordid` when calling `keyword_view`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'keywordid' in params:
            form_params.append(('Keywordid', params['keywordid']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/keyword/view.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shortcode_getinboundsms(self, **kwargs):  # noqa: E501
        """List Inbound SMS  # noqa: E501

        List All Inbound ShortCode  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_getinboundsms(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: Number of individual resources listed in the response per page
        :param str _from: From Number to Inbound ShortCode
        :param str shortcode: Only list messages sent to this Short Code
        :param str datecreated: Only list messages sent with the specified date
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.shortcode_getinboundsms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.shortcode_getinboundsms_with_http_info(**kwargs)  # noqa: E501
            return data

    def shortcode_getinboundsms_with_http_info(self, **kwargs):  # noqa: E501
        """List Inbound SMS  # noqa: E501

        List All Inbound ShortCode  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_getinboundsms_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: Number of individual resources listed in the response per page
        :param str _from: From Number to Inbound ShortCode
        :param str shortcode: Only list messages sent to this Short Code
        :param str datecreated: Only list messages sent with the specified date
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'pagesize', '_from', 'shortcode', 'datecreated']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shortcode_getinboundsms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'datecreated' in params:
            query_params.append(('Datecreated', params['datecreated']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'page' in params:
            form_params.append(('page', params['page']))  # noqa: E501
        if 'pagesize' in params:
            form_params.append(('pagesize', params['pagesize']))  # noqa: E501
        if '_from' in params:
            form_params.append(('from', params['_from']))  # noqa: E501
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/shortcode/getinboundsms.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shortcode_listshortcode(self, **kwargs):  # noqa: E501
        """List Shortcodes  # noqa: E501

        Retrieve a list of shortcode assignment associated with your Ytel account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_listshortcode(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: Number of individual resources listed in the response per page
        :param str shortcode: Only list keywords of shortcode
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.shortcode_listshortcode_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.shortcode_listshortcode_with_http_info(**kwargs)  # noqa: E501
            return data

    def shortcode_listshortcode_with_http_info(self, **kwargs):  # noqa: E501
        """List Shortcodes  # noqa: E501

        Retrieve a list of shortcode assignment associated with your Ytel account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_listshortcode_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: Number of individual resources listed in the response per page
        :param str shortcode: Only list keywords of shortcode
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'pagesize', 'shortcode']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shortcode_listshortcode" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'shortcode' in params:
            query_params.append(('Shortcode', params['shortcode']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'page' in params:
            form_params.append(('page', params['page']))  # noqa: E501
        if 'pagesize' in params:
            form_params.append(('pagesize', params['pagesize']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/shortcode/listshortcode.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shortcode_sendsms(self, shortcode, to, templateid, data, **kwargs):  # noqa: E501
        """Send SMS  # noqa: E501

        Send an SMS from a Ytel ShortCode  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_sendsms(shortcode, to, templateid, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: The Short Code number that is the sender of this message (required)
        :param str to: A valid 10-digit number that should receive the message (required)
        :param str templateid: The unique identifier for the template used for the message (required)
        :param str data: format of your data, example: {companyname}:test,{otpcode}:1234 (required)
        :param str method: Specifies the HTTP method used to request the required URL once the Short Code message is sent.
        :param str message_status_callback: URL that can be requested to receive notification when Short Code message was sent.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.shortcode_sendsms_with_http_info(shortcode, to, templateid, data, **kwargs)  # noqa: E501
        else:
            (data) = self.shortcode_sendsms_with_http_info(shortcode, to, templateid, data, **kwargs)  # noqa: E501
            return data

    def shortcode_sendsms_with_http_info(self, shortcode, to, templateid, data, **kwargs):  # noqa: E501
        """Send SMS  # noqa: E501

        Send an SMS from a Ytel ShortCode  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_sendsms_with_http_info(shortcode, to, templateid, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: The Short Code number that is the sender of this message (required)
        :param str to: A valid 10-digit number that should receive the message (required)
        :param str templateid: The unique identifier for the template used for the message (required)
        :param str data: format of your data, example: {companyname}:test,{otpcode}:1234 (required)
        :param str method: Specifies the HTTP method used to request the required URL once the Short Code message is sent.
        :param str message_status_callback: URL that can be requested to receive notification when Short Code message was sent.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shortcode', 'to', 'templateid', 'data', 'method', 'message_status_callback']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shortcode_sendsms" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shortcode' is set
        if ('shortcode' not in params or
                params['shortcode'] is None):
            raise ValueError("Missing the required parameter `shortcode` when calling `shortcode_sendsms`")  # noqa: E501
        # verify the required parameter 'to' is set
        if ('to' not in params or
                params['to'] is None):
            raise ValueError("Missing the required parameter `to` when calling `shortcode_sendsms`")  # noqa: E501
        # verify the required parameter 'templateid' is set
        if ('templateid' not in params or
                params['templateid'] is None):
            raise ValueError("Missing the required parameter `templateid` when calling `shortcode_sendsms`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `shortcode_sendsms`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'shortcode' in params:
            form_params.append(('shortcode', params['shortcode']))  # noqa: E501
        if 'to' in params:
            form_params.append(('to', params['to']))  # noqa: E501
        if 'templateid' in params:
            form_params.append(('templateid', params['templateid']))  # noqa: E501
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
        if 'method' in params:
            form_params.append(('Method', params['method']))  # noqa: E501
        if 'message_status_callback' in params:
            form_params.append(('MessageStatusCallback', params['message_status_callback']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/shortcode/sendsms.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shortcode_updateshortcode(self, shortcode, **kwargs):  # noqa: E501
        """Update Shortcode  # noqa: E501

        Update Assignment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_updateshortcode(shortcode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: List of valid shortcode to your Ytel account (required)
        :param str friendly_name: User generated name of the shortcode
        :param str callback_url: URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the call is finished.
        :param str callback_method: Specifies the HTTP method used to request the required StatusCallBackUrl once call connects.
        :param str fallback_url: URL used if any errors occur during execution of InboundXML or at initial request of the required Url provided with the POST.
        :param str fallback_url_method: Specifies the HTTP method used to request the required FallbackUrl once call connects.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.shortcode_updateshortcode_with_http_info(shortcode, **kwargs)  # noqa: E501
        else:
            (data) = self.shortcode_updateshortcode_with_http_info(shortcode, **kwargs)  # noqa: E501
            return data

    def shortcode_updateshortcode_with_http_info(self, shortcode, **kwargs):  # noqa: E501
        """Update Shortcode  # noqa: E501

        Update Assignment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_updateshortcode_with_http_info(shortcode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: List of valid shortcode to your Ytel account (required)
        :param str friendly_name: User generated name of the shortcode
        :param str callback_url: URL that can be requested to receive notification when call has ended. A set of default parameters will be sent here once the call is finished.
        :param str callback_method: Specifies the HTTP method used to request the required StatusCallBackUrl once call connects.
        :param str fallback_url: URL used if any errors occur during execution of InboundXML or at initial request of the required Url provided with the POST.
        :param str fallback_url_method: Specifies the HTTP method used to request the required FallbackUrl once call connects.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shortcode', 'friendly_name', 'callback_url', 'callback_method', 'fallback_url', 'fallback_url_method']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shortcode_updateshortcode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shortcode' is set
        if ('shortcode' not in params or
                params['shortcode'] is None):
            raise ValueError("Missing the required parameter `shortcode` when calling `shortcode_updateshortcode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501
        if 'friendly_name' in params:
            form_params.append(('FriendlyName', params['friendly_name']))  # noqa: E501
        if 'callback_url' in params:
            form_params.append(('CallbackUrl', params['callback_url']))  # noqa: E501
        if 'callback_method' in params:
            form_params.append(('CallbackMethod', params['callback_method']))  # noqa: E501
        if 'fallback_url' in params:
            form_params.append(('FallbackUrl', params['fallback_url']))  # noqa: E501
        if 'fallback_url_method' in params:
            form_params.append(('FallbackUrlMethod', params['fallback_url_method']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/shortcode/updateshortcode.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shortcode_viewshortcode(self, shortcode, **kwargs):  # noqa: E501
        """View Shortcode  # noqa: E501

        The response returned here contains all resource properties associated with the given Shortcode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_viewshortcode(shortcode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: List of valid Shortcode to your Ytel account (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.shortcode_viewshortcode_with_http_info(shortcode, **kwargs)  # noqa: E501
        else:
            (data) = self.shortcode_viewshortcode_with_http_info(shortcode, **kwargs)  # noqa: E501
            return data

    def shortcode_viewshortcode_with_http_info(self, shortcode, **kwargs):  # noqa: E501
        """View Shortcode  # noqa: E501

        The response returned here contains all resource properties associated with the given Shortcode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.shortcode_viewshortcode_with_http_info(shortcode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str shortcode: List of valid Shortcode to your Ytel account (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shortcode']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shortcode_viewshortcode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shortcode' is set
        if ('shortcode' not in params or
                params['shortcode'] is None):
            raise ValueError("Missing the required parameter `shortcode` when calling `shortcode_viewshortcode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/shortcode/viewshortcode.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def template_lists(self, **kwargs):  # noqa: E501
        """List Templates  # noqa: E501

        List Shortcode Templates by Type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.template_lists(async=True)
        >>> result = thread.get()

        :param async bool
        :param str type: The type (category) of template Valid values: marketing, authorization
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: The count of objects to return per page.
        :param str shortcode: Only list templates of type
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.template_lists_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.template_lists_with_http_info(**kwargs)  # noqa: E501
            return data

    def template_lists_with_http_info(self, **kwargs):  # noqa: E501
        """List Templates  # noqa: E501

        List Shortcode Templates by Type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.template_lists_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str type: The type (category) of template Valid values: marketing, authorization
        :param int page: The page count to retrieve from the total results in the collection. Page indexing starts at 1.
        :param int pagesize: The count of objects to return per page.
        :param str shortcode: Only list templates of type
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'page', 'pagesize', 'shortcode']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method template_lists" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'type' in params:
            form_params.append(('type', params['type']))  # noqa: E501
        if 'page' in params:
            form_params.append(('page', params['page']))  # noqa: E501
        if 'pagesize' in params:
            form_params.append(('pagesize', params['pagesize']))  # noqa: E501
        if 'shortcode' in params:
            form_params.append(('Shortcode', params['shortcode']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/template/lists.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def template_view(self, template_id, **kwargs):  # noqa: E501
        """View Template  # noqa: E501

        View a Shared ShortCode Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.template_view(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: The unique identifier for a template object (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.template_view_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.template_view_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def template_view_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """View Template  # noqa: E501

        View a Shared ShortCode Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.template_view_with_http_info(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: The unique identifier for a template object (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method template_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `template_view`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'template_id' in params:
            form_params.append(('TemplateId', params['template_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/template/view.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
